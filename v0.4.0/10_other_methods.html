

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Other Optimization Methods &mdash; Krotov 7c20d3f documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/version-alert.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/SVG"], "TeX": {"extensions": ["AMSmath.js", "AMSsymbols.js"], "Macros": {"tr": ["{\\operatorname{tr}}", 0], "diag": ["{\\operatorname{diag}}", 0], "abs": ["{\\operatorname{abs}}", 0], "pop": ["{\\operatorname{pop}}", 0], "ee": ["{\\text{e}}", 0], "ii": ["{\\text{i}}", 0], "aux": ["{\\text{aux}}", 0], "opt": ["{\\text{opt}}", 0], "tgt": ["{\\text{tgt}}", 0], "init": ["{\\text{init}}", 0], "lab": ["{\\text{lab}}", 0], "rwa": ["{\\text{rwa}}", 0], "bra": ["{\\langle#1\\vert}", 1], "ket": ["{\\vert#1\\rangle}", 1], "Bra": ["{\\left\\langle#1\\right\\vert}", 1], "Braket": ["{\\left\\langle #1\\vphantom{#2} \\mid #2\\vphantom{#1}\\right\\rangle}", 2], "ketbra": ["{\\vert#1\\rangle\\!\\langle#2\\vert}", 2], "Ket": ["{\\left\\vert#1\\right\\rangle}", 1], "mat": ["{\\mathbf{#1}}", 1], "op": ["{\\hat{#1}}", 1], "Op": ["{\\hat{#1}}", 1], "dd": ["{\\,\\text{d}}", 0], "daggered": ["{^{\\dagger}}", 0], "transposed": ["{^{\\text{T}}}", 0], "Liouville": ["{\\mathcal{L}}", 0], "DynMap": ["{\\mathcal{E}}", 0], "identity": ["{\\mathbf{1}}", 0], "Norm": ["{\\left\\lVert#1\\right\\rVert}", 1], "norm": ["{\\lVert#1\\rVert}", 1], "Abs": ["{\\left\\vert#1\\right\\vert}", 1], "avg": ["{\\langle#1\\rangle}", 1], "Avg": ["{\\left\\langle#1\\right\\rangle}", 1], "AbsSq": ["{\\left\\vert#1\\right\\vert^2}", 1], "Re": ["{\\operatorname{Re}}", 0], "Im": ["{\\operatorname{Im}}", 0], "Real": ["{\\mathbb{R}}", 0], "Complex": ["{\\mathbb{C}}", 0], "Integer": ["{\\mathbb{N}}", 0]}}, "tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/mycss.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="References" href="99_bibliography.html" />
    <link rel="prev" title="How-Tos" href="09_howto.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Krotov
          

          
          </a>

          
            
            
              <div class="version">
                0.4.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_overview.html">Krotov Python Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_krotovs_method.html">Krotov’s Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_qutip_usage.html">Using Krotov with QuTiP</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_howto.html">How-Tos</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Other Optimization Methods</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#gradient-ascent-pulse-engineering-grape">GRadient Ascent Pulse Engineering (GRAPE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grape-in-qutip">GRAPE in QuTiP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gradient-free-optimization">Gradient-free optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#choosing-an-optimization-method">Choosing an optimization method</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="99_bibliography.html">References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="API/krotov.html">API of the Krotov package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Krotov</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          





















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Other Optimization Methods</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="other-optimization-methods">
<h1>Other Optimization Methods<a class="headerlink" href="#other-optimization-methods" title="Permalink to this headline">¶</a></h1>
<p>At its core, Krotov’s method is a gradient-based optimization method,
and most directly compares to GRadient Ascent Pulse Engineering
(GRAPE) <a class="bibtex reference internal" href="99_bibliography.html#khanejajmr05" id="id1">[24]</a>, another gradient-based method
widely used in quantum control <a class="bibtex reference internal" href="99_bibliography.html#glaserepjd2015" id="id2">[25]</a>. We
therefore compare to GRAPE first and highlight the difference with
gradient-free methods further below.</p>
<div class="section" id="gradient-ascent-pulse-engineering-grape">
<span id="grape"></span><h2>GRadient Ascent Pulse Engineering (GRAPE)<a class="headerlink" href="#gradient-ascent-pulse-engineering-grape" title="Permalink to this headline">¶</a></h2>
<p>The GRAPE method looks at the direct gradient <span class="math notranslate nohighlight">\(\partial J_T/\partial
\epsilon_j\)</span> with respect to any control parameter <span class="math notranslate nohighlight">\(\epsilon_j\)</span>.  The
value of the control parameter is then updated in the direction of the
gradient, although in all practical applications, a numerical estimate of the
Hessian <span class="math notranslate nohighlight">\(\partial^2 J_T/\partial \epsilon_j \partial \epsilon_{j^\prime}\)</span>
should also be included in calculation of the update. The L-BFGS-B quasi-Newton
method <a class="bibtex reference internal" href="99_bibliography.html#byrdsjsc1995" id="id3">[26]</a><a class="bibtex reference internal" href="99_bibliography.html#zhuatms97" id="id4">[27]</a> is most commonly used for this purpose.</p>
<p>The control parameter <span class="math notranslate nohighlight">\(\epsilon_j\)</span> may be the value of a control field in
a particular time interval. When the control field is a discretization of a
time-continuous control, e.g. using the piecewise-constant scheme as in
<a class="reference internal" href="06_krotovs_method.html#figkrotovscheme"><span class="std std-numref">Fig. 1</span></a>, and for typical functionals, the numerical effort
required for the calculation of the gradient <span class="math notranslate nohighlight">\(\partial J_T/\partial
\epsilon_j\)</span> is nearly identical to the effort for a single iteration of
Krotov’s method. In both cases, a forward and backward propagation over the
entire time grid is carried out, which determines almost entirely the numerical
effort. This requirement results from the derivative of the complex overlaps
<span class="math notranslate nohighlight">\(\tau_k\)</span> between the propagated states <span class="math notranslate nohighlight">\(\{\ket{\phi_k(T)}\}\)</span> and
the target states <span class="math notranslate nohighlight">\(\{\ket{\phi_k^{\tgt}}\}\)</span>, on which the standard
functionals are based, cf. Eq. <a class="reference internal" href="06_krotovs_method.html#equation-tauk">(3)</a>. The relevant term in the gradient is
then <a class="bibtex reference internal" href="99_bibliography.html#khanejajmr05" id="id5">[24]</a></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
  \frac{\partial \tau_k}{\partial \epsilon_j}
  &amp;= \frac{\partial}{\partial \epsilon_j}
    \big\langle \phi_k^{\tgt} \big\vert
            \Op{U}^{(i)}_{nt-1} \dots \Op{U}^{(i)}_{j} \dots
            \Op{U}^{(i)}_{1} \big\vert \phi_k \big\rangle \\
  &amp;=
    \underbrace{%
        \big\langle \phi_k^{\tgt} \big\vert
          \Op{U}^{(i)}_{nt-1} \dots \Op{U}^{(i)}_{j+1}}_{%
      \bra{\chi^{(i)}_k(t_{j+1})}
     }
      \, \frac{\partial\Op{U}^{(i)}_{j}}{\partial\epsilon_j} \,
     \underbrace{%
       \Op{U}^{(i)}_{j-1} \dots \Op{U}^{(i)}_{1} \big\vert
        \phi_k \big\rangle}_{%
      \ket{\phi^{(i)}_k(t_j)}
     }\,,
  \end{split}\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(\Op{U}^{(i)}_j\)</span> the time evolution operator for the time
interval <span class="math notranslate nohighlight">\(j\)</span>, using the guess controls in iteration <span class="math notranslate nohighlight">\((i)\)</span> of
the optimization. We end up with backward-propagated states
<span class="math notranslate nohighlight">\(\ket{\chi_k(t_{j+1})}\)</span> and forward-propagated states
<span class="math notranslate nohighlight">\(\ket{\phi_k(t_j)}\)</span>. This is to be compared with the first-order
update equation <a class="reference internal" href="06_krotovs_method.html#equation-krotov-first-order-update">(8)</a> for Krotov’s method.</p>
<p>In this example of (discretized) time-continuous controls, both GRAPE
and Krotov’s method can generally be used interchangeably. The benefits
of Krotov’s method compared to GRAPE are <a class="bibtex reference internal" href="99_bibliography.html#eitanpra11" id="id6">[28]</a>:</p>
<ul class="simple">
<li><p>Krotov’s method mathematically guarantees monotonic convergence in
the continuous limit.</p></li>
<li><p>Krotov’s method does not require a line search to determine the ideal
magnitude of the pulse update in the direction of the gradient.</p></li>
<li><p>The sequential nature of Krotov’s update scheme, where information
from earlier times enters the update at later times,
cf. <a class="reference internal" href="06_krotovs_method.html#figkrotovscheme"><span class="std std-numref">Fig. 1</span></a>, results in
faster convergence than the concurrent update in
GRAPE <a class="bibtex reference internal" href="99_bibliography.html#machnespra11" id="id7">[29]</a><a class="bibtex reference internal" href="99_bibliography.html#jaegerpra14" id="id8">[30]</a>. However, this
advantage disappears as the optimization approaches the
optimum <a class="bibtex reference internal" href="99_bibliography.html#eitanpra11" id="id9">[28]</a>.</p></li>
<li><p>The choice of functional <span class="math notranslate nohighlight">\(J_T\)</span> in Krotov’s method only enters
in the boundary condition for the backward-propagated states,
Eq. <a class="reference internal" href="06_krotovs_method.html#equation-chi-boundary">(11)</a>, while the update equation stays the same otherwise.
In contrast, for functionals that do not depend trivially on the overlaps
<span class="math notranslate nohighlight">\(\tau_k = \Braket{\phi_k^\tgt}{\phi_k(T)}\)</span>, the evaluation of
the gradient in GRAPE may deviate significantly from its usual form,
requiring a problem-specific implementation from scratch.</p></li>
</ul>
<p>GRAPE has a significant advantage if the controls are not
time-continuous, but are <em>physically</em> piecewise constant (“bang-bang
control”). The calculation of the GRAPE-gradient is unaffected by this,
whereas Krotov’s method can break down when the controls are not
approximately continuous. QuTiP contains an implementation of GRAPE
limited to this use case.</p>
<p>GRAPE (with the second-order derivative estimates by the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/optimize.minimize-lbfgsb.html">L-BFGS-B</a>
algorithm) has been shown to converge faster than Krotov’s method when
the optimization is close to the optimum. This is because Krotov’s
method only considers the first-order-gradient with respect to the
control field <a class="bibtex reference internal" href="99_bibliography.html#eitanpra11" id="id10">[28]</a>, and this derivative
vanishes close to the optimum. This is true even for the Krotov update
with the additional non-linear term, discussed in
the <a class="reference internal" href="06_krotovs_method.html#secondorderkrotov"><span class="std std-ref">Optimization of non-linear problems or non-convex functionals</span></a>. There, “second-order” refers to the expansion of
the functional with respect to the states, not to the order of the derivative.</p>
</div>
<div class="section" id="grape-in-qutip">
<span id="grapeinqutip"></span><h2>GRAPE in QuTiP<a class="headerlink" href="#grape-in-qutip" title="Permalink to this headline">¶</a></h2>
<p>An implementation of GRAPE is included in QuTiP, see the <a class="reference external" href="http://qutip.org/docs/latest/guide/guide-control.html">section on Quantum
Optimal Control in the QuTiP docs</a>.  It is used via the
<a class="reference external" href="http://qutip.org/docs/latest/apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse" title="(in QuTiP: Quantum Toolbox in Python v4.4)"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.control.pulseoptim.optimize_pulse()</span></code></a> function.
However, some of the design choices in QuTiP’s GRAPE effectively limit
the routine to applications with physically piecewise-constant pulses (where
GRAPE has an advantage over Krotov’s method, as discussed in the previous
section).</p>
<p>For discretized time-continuous pulses, the implementation of Krotov’s method
in <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> has the following advantages over
<a class="reference external" href="http://qutip.org/docs/latest/apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse" title="(in QuTiP: Quantum Toolbox in Python v4.4)"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.control.pulseoptim.optimize_pulse()</span></code></a>:</p>
<ul class="simple">
<li><p>Krotov’s method can optimize for more than one control field at the same time
(hence the name of the routine <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a> compared to
<a class="reference external" href="http://qutip.org/docs/latest/apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse" title="(in QuTiP: Quantum Toolbox in Python v4.4)"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulse()</span></code></a>).</p></li>
<li><p>Krotov’s method optimizes a list of <a class="reference internal" href="API/krotov.objectives.html#krotov.objectives.Objective" title="krotov.objectives.Objective"><code class="xref py py-class docutils literal notranslate"><span class="pre">Objective</span></code></a> instances
simultaneously. The optimization for multiple simultaneous objectives in
QuTiP’s GRAPE implementation is limited to optimizing a quantum gate. Other
uses of simultaneous objectives, such as optimizing for robustness, are not
available.</p></li>
<li><p>Krotov’s method can start from an arbitrary set of guess controls. In the
GRAPE implementation, guess pulses can only be chosen from a specific set of
options (including “random”). Again, this makes sense for a control field
that is piecewise constant with relatively few switching points, but is very
disadvantageous for time-continuous controls.</p></li>
<li><p>Krotov’s method has complete flexibility in which propagation method is used
(via the <cite>propagator</cite> argument to <a class="reference internal" href="API/krotov.optimize.html#krotov.optimize.optimize_pulses" title="krotov.optimize.optimize_pulses"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimize_pulses()</span></code></a>), while QuTiP’s
GRAPE only allows to choose between fixed number of methods for
time-propagation. Supplying a problem-specific propagator is not possible.</p></li>
</ul>
<p>Thus, QuTiP’s GRAPE implementation and the implementation of Krotov’s method in
this package complement each other, but will not compare directly.</p>
</div>
<div class="section" id="gradient-free-optimization">
<h2>Gradient-free optimization<a class="headerlink" href="#gradient-free-optimization" title="Permalink to this headline">¶</a></h2>
<p>In situations where the controls can be reduced to a relatively small
number of controllable parameters (typically less than 20),
gradient-free optimization becomes feasible. The most straightforward
use case are controls with an analytic shape (maybe due to the
constraints of an experimental setup), with just a few free parameters.
As an example, consider control pulses that are restricted to Gaussian
pulses, so that the only free parameters are the peak amplitude and
pulse width. The control parameters are not required to be parameters of
a time-dependent control, but may also be static parameters in the
Hamiltonian, e.g. the polarization of the laser beams utilized in an
experiment <a class="bibtex reference internal" href="99_bibliography.html#hornnjp2018" id="id11">[31]</a>.</p>
<p>A special case of gradient-free optimization is the Chopped RAndom Basis
(CRAB) method <a class="bibtex reference internal" href="99_bibliography.html#doriaprl11" id="id12">[32]</a><a class="bibtex reference internal" href="99_bibliography.html#canevapra2011" id="id13">[33]</a>. The essence
of CRAB is in the specific choice of the parametrization in terms of a
low-dimensional <em>random</em> basis, as the name implies. Thus, it can be
used when the parametrization is not as “obvious” as in the case of
direct free parameters in the pulse shape discussed above. The
optimization itself is normally performed by Nelder-Mead simplex based
on this parametrization, although any other gradient-free method could
be used as well.</p>
<p>An implementation of CRAB is included in QuTiP, see <a class="reference external" href="http://qutip.org/docs/latest/guide/guide-control.html#the-crab-algorithm">QuTiP’s documentation of
CRAB</a>, and uses the same <a class="reference external" href="http://qutip.org/docs/latest/apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse" title="(in QuTiP: Quantum Toolbox in Python v4.4)"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.control.pulseoptim.optimize_pulse()</span></code></a>
interface as the GRAPE method discussed above (<a class="reference internal" href="#grapeinqutip"><span class="std std-ref">GRAPE in QuTiP</span></a>) with the
same limitations.</p>
<p>Gradient-free optimization does not require backward propagation, but
only a forward propagation of the initial states and the evaluation of
an arbitrary functional <span class="math notranslate nohighlight">\(J_T\)</span>. It also does not require the
storage of states. However, the number of iterations can grow extremely
large, especially with an increasing number of control parameters. Thus,
an optimization with a gradient-free method is not necessarily more
efficient overall compared to a gradient-based optimization with much
faster convergence. For only a few parameters, however, it can be highly
efficient.</p>
<p>This makes gradient-free optimization useful for “pre-optimization”,
that is, for finding guess controls that are then further optimized with
a gradient-based method <a class="bibtex reference internal" href="99_bibliography.html#goerzepjqt2015" id="id14">[34]</a>. A further
benefit of gradient-free optimization is that it can be applied to <em>any</em>
functional, even if <span class="math notranslate nohighlight">\(\partial J_T / \partial \bra{\phi_k}\)</span> or
<span class="math notranslate nohighlight">\(\partial J_T / \partial \epsilon_j\)</span> cannot be calculated.</p>
<p>A possible drawback of gradient-free optimization is that is also prone
to get stuck in local optimization minima. To some extent, this can be
mitigated by trying different guess pulses, by
re-parametrization <a class="bibtex reference internal" href="99_bibliography.html#rachpra2015" id="id15">[35]</a>, or by using some of
the <em>global</em> methods available in the NLopt
package <a class="bibtex reference internal" href="99_bibliography.html#nlopt" id="id16">[36]</a>.</p>
<p>Generally, gradient-free optimization can be easily realized directly in
QuTiP or any other software package for the simulation of quantum
dynamics:</p>
<ul class="simple">
<li><p>Write a function that takes an array of optimization parameters as
input and returns a figure of merit. This function would, e.g.,
construct a numerical control pulse from the control parameters,
simulate the dynamics using <a class="reference external" href="http://qutip.org/docs/latest/apidoc/functions.html#qutip.mesolve.mesolve" title="(in QuTiP: Quantum Toolbox in Python v4.4)"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve.mesolve()</span></code></a>, and evaluate a
figure of merit (like the overlap with a target state).</p></li>
<li><p>Pass the function to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize" title="(in SciPy v1.3.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.optimize.minimize()</span></code></a> for gradient-free
optimization.</p></li>
</ul>
<p>The implementation in scipy.optimize.minimize allows to choose between
different optimization methods, with Nelder-Mead simplex being the
default. There exist also more advanced methods such as <a class="reference external" href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#sbplx-based-on-subplex">Subplex</a> in
<a class="reference external" href="https://nlopt.readthedocs.io/">NLopt</a> <a class="bibtex reference internal" href="99_bibliography.html#nlopt" id="id17">[36]</a> that may be worth exploring for
improvements in numerical efficiency, and additional functionality such
as support for non-linear constraints.</p>
</div>
<div class="section" id="choosing-an-optimization-method">
<span id="id18"></span><h2>Choosing an optimization method<a class="headerlink" href="#choosing-an-optimization-method" title="Permalink to this headline">¶</a></h2>
<div class="figure align-default" id="id22">
<span id="figoctdecisiontree"></span><a class="reference internal image-reference" href="_images/oct_decision_tree.svg"><img alt="decision tree." src="_images/oct_decision_tree.svg" width="100%" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">Decision tree for the choice of an optimization method</span><a class="headerlink" href="#id22" title="Permalink to this image">¶</a></p>
</div>
<p>Whether to use a gradient-free optimization method, GRAPE, or Krotov’s
method depends on the size of the problem, the requirements on the
control pulse, and the optimization functional. Gradient-free methods
should be used if the number of independent control parameters is
smaller than 20, or the functional is of a form that does not allow to
calculate gradients easily. It is always a good idea to use a
gradient-free method to obtain improved guess pulses for use with a
gradient-based method <a class="bibtex reference internal" href="99_bibliography.html#goerzepjqt2015" id="id19">[34]</a>.</p>
<p>GRAPE should be used if the control parameters are discrete, such as on
a coarse-grained time grid, and the derivative of <span class="math notranslate nohighlight">\(J_T\)</span> with
respect to each control parameter is easily computable. Note that the
implementation provided in QuTiP is limited to state-to-state
transitions and quantum gates, even though the method is generally
applicable to a wider range of objectives.</p>
<p>Krotov’s method should be used if the control is near-continuous, and if
the derivative of <span class="math notranslate nohighlight">\(J_T\)</span> with respect to the states,
Eq. <a class="reference internal" href="06_krotovs_method.html#equation-chi-boundary">(11)</a>, can be calculated. When
these conditions are met, Krotov’s method gives excellent convergence.
However, as discussed in the section <a class="reference internal" href="#grape"><span class="std std-ref">GRadient Ascent Pulse Engineering (GRAPE)</span></a>, it is
often observed to slow down when getting close to the minimum of
<span class="math notranslate nohighlight">\(J_T\)</span>, as the first order derivative vanishes close to the
optimum. For the “best of both worlds”, it can be beneficial to switch
from Krotov’s method to GRAPE with L-BFGS-B in the final stage of the
optimization <a class="bibtex reference internal" href="99_bibliography.html#machnespra11" id="id20">[29]</a>. It has also been proposed
to modify Krotov’s method to include information from the
quasi-Hessian <a class="bibtex reference internal" href="99_bibliography.html#eitanpra11" id="id21">[28]</a>.</p>
<p>The decision tree in <a class="reference internal" href="#figoctdecisiontree"><span class="std std-numref">Fig. 2</span></a> can guide the
choice of an optimization method. The key deciding factor between
gradient-free and gradient-based is the number of control parameters.
For gradient-free optimization, CRAB’s random parametrization is useful
for when there is no obviously better parametrization of the control
(e.g., the control is restricted to an analytic pulse shape and we only
want to optimize the free parameters of that pulse shape). For
gradient-based methods, the decision between GRAPE and Krotov depends
mainly on whether the pulses are approximately time-continuous (up to
discretization), or are of bang-bang type.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="99_bibliography.html" class="btn btn-neutral float-right" title="References" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="09_howto.html" class="btn btn-neutral float-left" title="How-Tos" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Michael Goerz et al.
      <span class="lastupdated">
        Last updated on Dec 14, 2019.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>